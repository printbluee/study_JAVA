1. 자바 프로그래밍 기초

자료형
기본 자료형		primitive type
참조 자료형		referance type
------------------------------------------------------------------------------------------------------------
<기본 자료형>
정수형			byte - char - short - int (기본) - long
실수형			float - double(기본)
논리형			boolean
------------------------------------------------------------------------------------------------------------
문자			' ' - 작은 따옴표
문자열			" " - 큰 따옴표
------------------------------------------------------------------------------------------------------------
<리터럴>			Literal
			그 자체로의 값 의미
정수형 리터럴		int / 접미사 L
실수형 리터럴 		float / 접미사 F
논리형 리터럴		boolean 
논리형 예약어 저장값	true : 1
			false : 0
문자형 리터럴		int
문자열 리터럴 		String

<상수>			constant
			이름이 있는 값
			초기화한 값으로 고정 (변경 불가능)
			변수는 무조건 대문자
			변수 앞에 final
------------------------------------------------------------------------------------------------------------
<Final>			금지
final 변수			초기화한 값으로 변수의 값 고정
			값 변경 금지
			변수를 상수화 시켰다 라고 말함
			변수명은 대문자로
final 메서드
final 클래스
------------------------------------------------------------------------------------------------------------
<실수형의 정밀도>		
float			6자리
double			15자리
------------------------------------------------------------------------------------------------------------
<산술 연산자>
대입 연산자 		=
더하기			+
빼기			-
곱하기			*
몫			/
나머지			%

System.out.println("덧셈 : " + (num1 + num2)); ==> 괄호 안해도 되지만 직관성 높이기 위해 괄호 사용
------------------------------------------------------------------------------------------------------------
<관계 연산자> - 왼쪽 기준
<			작다 (미만)
>			크다 (초과)
<=			작거나 같다 (이하)
>=			크거나 같다 (이상)
!=			같지 않다 (다르다)
==			같다
------------------------------------------------------------------------------------------------------------
<논리 연산자>
&&			and 연산자
||			or 연산자
! 			not 연산자

true&&true		true
true&&false		false
false&&false		false

true||true			true
true||false			true // 왼쪽부터 실행되는데 true 면 뒤에 피연산자는 계산 안해도 됨
false||false		false

!true			false
!false			true
------------------------------------------------------------------------------------------------------------
<증가/감소 연산자>
++ 			피연산자의 값 1 증가
-- 			피연산자의 값 1 감소
------------------------------------------------------------------------------------------------------------
<삼항 연산자>
문법 			(조건식) ? true : false;
------------------------------------------------------------------------------------------------------------
<형변환>			강제 형변환 한다고 잘못된 값을 저장하지 않음
			접미사 L, F도 강제 형변환에 포함
강제 형변환		
자동 형변환		
------------------------------------------------------------------------------------------------------------
Scanner
next()			String 을 읽음 / 단, 띄어쓰기 뒷 부분 읽지 않음
nextLine()			String 을 읽음 / 띄어쓰기 포함하여 한 줄을 읽음
nextInt()			int 를 읽음
nextBoolean()		boolean 을 읽음
nextByte()		byte 를 읽음
nextShort()		short 를 읽음
nextLong()		long 을 읽음
nextFloat()		float 을 읽음
nextDouble()		double 을 읽음
------------------------------------------------------------------------------------------------------------
println 과 print 차이점	println 는 다음 라인까지 출력, print 는 입력까지
printf			fomat
------------------------------------------------------------------------------------------------------------
이스케이프 문자
\n 			아래 줄바꿈
\t 			탭
\ \ 			문자열 \
\' 			문자열 '
\" 			문자열 "
------------------------------------------------------------------------------------------------------------
<제어문>
조건문			if / swith	
			if      -> swith 바꿀 수 x
			swith -> if      바꿀 수 o
(if 문)			if / else if / else
(swith 문)			case (라벨)
			세미콜론 x
			float 타입 사용 x
			case 는 리터럴 값 변수가 올 수 없으며 상수만 가능
			조건마다 break 사용 (선택)

반복문			while / do~while / for
			반복 횟수 결정 여부에 따라 while 문 쓸지, for 문 쓸지 결정
			반복 : for문 / 반복x : while문	
			outer 사용해서 반복문 탈출
(while 문)			무한 루프 (loop)
			break
			continue
(do ~ while 문)		조건에 상관없이, 반복문 처음 한 번은 꼭 실행하고자 할 때
(for 문)			for (초기값; 조건식; 증감식)
------------------------------------------------------------------------------------------------------------
지역 변수			local variable
			영역 내에서 사용(접근) 가능, 영역 밖에서는 사용(접근) 불가능
------------------------------------------------------------------------------------------------------------
메소드 정의와 호출
메소드 정의 		모듈화
반환형(리턴형)		return type
			void
매개변수			prameter
			메소드, 생성자 선언할 때, 어떤 형태로 데이터 값이 들어올지 정의
			타입 생략 x
			ex) int a, int b o , int a, b x
인수/인자			argument
			메소드, 생성자 호출할 때 데이터를 매개변수에 값 전달
			ex) sum(3, 5)
가변인자			선언 형태 : type ... parameter
			ex) public static void sum(int ... args)
------------------------------------------------------------------------------------------------------------
<메소드 실행의 끝>
return			메소드 실행 끝
			리턴값을 호출한 쪽으로 넘겨줌
			결과값은 하나만 가능
method 의 body 		닫힌 중괄호
------------------------------------------------------------------------------------------------------------
<오버로딩 과 오버라이딩>
오버로딩 			overloading
			같은 이름의 메소드를 여러 개 정의
			단, 매개변수의 정보가 달라야함 (변수명은 같으나 위치가 달라도 o)
			반환형
------------------------------------------------------------------------------------------------------------
<객체 지향 프로그래밍>
(클래스와 객체)
class			자료형 (사용자(개발자) 정의 자료형)
			참조형 (referance type)
			클래스명        => 대문자로 시작
			클래스 내 멤버 => 변수, 메소드
객체			object, instance
			클래스로 생성된 실체화된 대상		
			모든 객체를 생성되는 인스턴스는 heap 영역에 저장
			객체가 heap 영역에 생성되면, 할당된 주소를 리턴(반환)
			생성된 객체는 반드시 주소를 통해 접근(간접 접근) / 바로 접근 x
객체 생성 문법		new 클래스명();		
			heap 영역에 할당
(변수종류)		
					메모리 영역	메모리 할당 시기		초기화 하지 않으면
			loacl variable	stack		해당 영역이 실행		쓰레기 값
			instance field	heap		인스턴스 생성될 때		0 or null
			static field	static (class)	class 가 load 될 때 	0 or null
공유 필드			loacl variable ==> instance field ==> static field 순으로 찾음


static field		클래스명으로 관리 ==> 클래스명으로 접근
			instance (object, 객체) 생서과 상관없이 접근(사용) 가능
			문법 : 클래스명.필드명;
static method		클래스명으로 관리 -> 클래스명으로 접근
			instance(object, 객체) 생성과 상관없이 호출(사용) 가능
			static(class) 메소드 내에서는 static 멤버만 접근(사용) 가능
			문법 : 클래스명.메서드명();
------------------------------------------------------------------------------------------------------------
setter/getter		class 에서 setter 메소드에서 지역 변수를 만들 때
			지역 변수와 멤버 변수가 같다 보니 접근을 하지 못해서 가려지는데
			이때 참조 변수를 만들고, this 연산자를 사용 !
			type : method
setter			멤버변수의 값을 설정하는 메소드
getter 			멤버변수의 값을 리턴하는 메소드
------------------------------------------------------------------------------------------------------------
constructor		생성자
			객체를 생성하면서 멤버변수(인스턴스 필드)를 초기화 하고자 할 때
			객체를 생성하면서 원하는 기능을 실행하기 위해서 (특정 멤버 메서드 호출)
			명시하지 않으면 기본 생성자 실행
			생성자 앞에 static 을 붙여야 main 메소드에서 호출 가능
			type : method
------------------------------------------------------------------------------------------------------------
인스턴스(객체) 생성 순서	1. 메모리 할당 -> 2. 생성자 할
------------------------------------------------------------------------------------------------------------
<Array 배열>		배열을 객체(인스턴스)로 생성 -> heap 영역에 생성
			주소로 접근(간접 접근)
			1차원 배열 / 2차원 배열
 			문법 : 자료형 [ ] 참조변수 = new 자료형[길이]; 			
			      : 자료형 [ ] 참조변수 = new 자료형[ ] { 요소값1, 요소값2, ... };
		 	      : 타입

.length 			배열의 길이 출력하는 메소드
.equals()			문자열 비교하는 메소드
.toString()		객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드
------------------------------------------------------------------------------------------------------------
Wrapper Class		자동형변환
			기본형 			          참조형
			[ primitive type ]    (boxing)   ----> [ reference type ] wrapper class
				           <---- (unboxing)
			byte - short - char - int - long        Byte - Short - Character - Integer - Long
			float - double		          Float - Double
			boolean			          Boolean
------------------------------------------------------------------------------------------------------------
Final			금지
final 변수			초기화한 값으로 변수의 값 고정
			변수를 상수화(시켰다고 말함) // 상수 constant
			이름 있음 (상수는 없지만 final 변수는 있다는 뜻)
			변수명 : 대문자
			cf ) literal 리터럴 : 값 그 자체, 이름 없음
final 메서드
final 클래스
------------------------------------------------------------------------------------------------------------
<상속>			좁은 의미 : class 의 재사용
			부모의 원하는 것만 상속 받을 수 없음, 무조건 다 받아야 함 
			-> 다 받기 싫으면 method overriding 
객체 생성 순서		1. 메모리 할당 : 부모 -> 자식
			2. 생성자 실행 : 부모 -> 자식
			
method overriding 	상속 관계에서 자식 class 가 부모 class 에 멤버 메소드를 재정의 한 것
			부모의 메소드 사용 x, 기능이 마음에 들지 않을 때 재정의
			선언부 그대로 => 반환명, 메소드명, 매개변수 정보가 같아야 함
method overloading	같은 이름의 메소드 여러 정의
			단, 매개변수의 정보(자료형, 개수)가 달라야함 
			반환형과 관련 x
			















